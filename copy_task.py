from functools import partial
from typing import Tuple

import jax
from jax import Array
import jax.interpreters
import jax.numpy as jnp
import equinox as eqx


class CopyTaskState(eqx.Module):
    rng: Array

    # Params
    vocab_size: int = eqx.field(static=True)
    min_seq_len: int = eqx.field(static=True)
    max_seq_len: int = eqx.field(static=True)

    # State vars
    first_sequence: Array # Sequence to remember
    second_sequence: Array # Sequence to recall
    seq_len: int
    curr_idx: int


def gen_new_sequence(rng: Array, vocab_size: int, min_seq_len: int, max_seq_len: int) -> Array:
    """Generates a new sequence for the copy task. The sequence is of the form:
    
    [0, x1, x2, ..., xn, 1, x1, x2, ..., xn] where n is a random integer between min_seq_len and max_seq_len.
    The sequence is generated by sampling integers between 2 and vocab_size.

    Args:
        rng (Array): RNG key
        vocab_size (int): Size of the vocabulary + 2 (0 and 1 are reserved for start and end tokens).
        min_seq_len (int): Minimum length of the sequence to remember.
        max_seq_len (int): Maximum length of the sequence to remember.

    Returns:
        Array: The generated sequence.
    """
    len_key, gen_key = jax.random.split(rng)
    
    seq_len = jax.random.randint(len_key, (1,), min_seq_len, max_seq_len + 1)[0] + 1

    sequence = jax.random.randint(gen_key, (max_seq_len,), 2, vocab_size)
    first_sequence = jnp.concat([jnp.array([0]), sequence])
    second_sequence = jnp.concat([jnp.array([1]), sequence])

    return first_sequence, second_sequence, seq_len


def init_ccopy_task(
        rng: Array,
        vocab_size: int = 10,
        min_seq_len: int = 1,
        max_seq_len: int = 5,
    ) -> CopyTaskState:
    """Initializes the copy task by generating a new sequence.
    
    Args:
        rng (Array): RNG key
        vocab_size (int, optional): Size of the vocabulary. Defaults to 10.
        min_seq_len (int, optional): Minimum length of the sequence. Defaults to 1.
        max_seq_len (int, optional): Maximum length of the sequence. Defaults to 10.
        
    Returns:
        CopyTaskState: The initial state of the copy task
    """
    gen_key, rng = jax.random.split(rng, 2)
    first_sequence, second_sequence, seq_len = gen_new_sequence(gen_key, vocab_size, min_seq_len, max_seq_len)
    return CopyTaskState(
        rng = rng,
        vocab_size = vocab_size,
        min_seq_len = min_seq_len,
        max_seq_len = max_seq_len,
        first_sequence = first_sequence,
        second_sequence = second_sequence,
        seq_len = seq_len,
        curr_idx = 0,
    )


def step_supervised_ccopy_task(state: CopyTaskState) -> Tuple[CopyTaskState, Array, Array]:
    """Returns the next input and target output for the copy task.

    Args:
        state (CopyTaskState): Current state of the copy task.

    Returns:
        Tuple[CopyTaskState, Array, Array]: The updated state, input and target output.
    """
    state = jax.lax.cond(
        state.curr_idx < 2 * state.seq_len - 1,
        lambda: state,
        lambda: init_ccopy_task(state.rng, state.vocab_size, state.min_seq_len, state.max_seq_len),
    )

    state = eqx.tree_at(lambda s: s.curr_idx, state, state.curr_idx + 1)
    x = jax.lax.cond(
        state.curr_idx - 1 < state.seq_len,
        lambda: state.first_sequence[state.curr_idx - 1],
        lambda: state.second_sequence[(state.curr_idx - 1) % state.seq_len],
    )
    y = jax.lax.cond(
        state.curr_idx <= state.seq_len,
        lambda: 0,
        lambda: state.second_sequence[state.curr_idx % state.seq_len],
    )
    loss_mask = jax.lax.cond(
        state.curr_idx <= state.seq_len,
        lambda: 0.0,
        lambda: 1.0,
    )

    return state, (x, y, loss_mask)


if __name__ == '__main__':

    rng = jax.random.PRNGKey(0)
    state = init_ccopy_task(rng)

    step_func = jax.jit(step_supervised_ccopy_task, backend='cpu')

    # Time how long step_func takes

    # %timeit jax.block_until_ready(step_func(state))

    import time
    n = int(1e6)
    start = time.time()
    for _ in range(n):
        state, x, y, loss_mask = step_func(state)
        
    print((time.time() - start) / n)


    # for _ in range(30):
    #     state, x, y = step_func(state)
    #     # print(x, y)